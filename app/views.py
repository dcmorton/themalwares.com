from app import app
from os import environ
from pymongo import MongoClient
from flask import render_template, flash, redirect, url_for, make_response
from .forms import searchform
import pyminizip
from os import unlink
import boto
import boto.s3.connection
import datetime

S3_ACCESS_KEY = environ.get('S3_ACCESS_KEY')
S3_SECRET_KEY = environ.get('S3_SECRET_KEY')
S3_BUCKET = environ.get('S3_BUCKET')
S3_MD5_BUCKET = environ.get('S3_MD5_BUCKET')
MONGO_IP_1 = environ.get('MONGO_IP_1')
MONGO_IP_2 = environ.get('MONGO_IP_2')
MONGO_PORT = environ.get('MONGO_PORT')
MONGO_DB = environ.get('MONGO_DB')
MONGO_COLLECTION = environ.get('MONGO_COLLECTION')
MONGO_USER = environ.get('MONGO_USER')
MONGO_PASS = environ.get('MONGO_PASS')
MONGO_REPLICA = environ.get('MONGO_REPLICA')

def mongoconnect():
        client = MongoClient("mongodb://"+MONGO_IP_1+":"+MONGO_PORT+","+MONGO_IP_2+":"+MONGO_PORT+"/?replicaset="+MONGO_REPLICA)
        client[MONGO_DB].authenticate(MONGO_USER, MONGO_PASS, mechanism='SCRAM-SHA-1')
        collection = client[MONGO_DB][MONGO_COLLECTION]
        return collection

@app.route('/')
@app.route('/index')
def index():
	collection = mongoconnect()
	uniq_samples = collection.count()
	uniq_samples = "{:,}".format(uniq_samples)
	return render_template("index.html", data=uniq_samples)

@app.route('/search', methods=['GET', 'POST'])
def search():
    collection = mongoconnect()
    form = searchform()
    if form.validate_on_submit():
    	if len(form.searchquery.data) == 32:
            if collection.find({'results.md5':form.searchquery.data},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False, 'results.scans': False}).count() != 0:
                    return redirect(url_for('samples', query=form.searchquery.data))
            else:
                    flash("Sample not found")
                    return redirect('/results')
    	elif len(form.searchquery.data) == 40:
    		if collection.find({'results.sha1':form.searchquery.data},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False, 'results.scans': False}).count() != 0:
                    return redirect(url_for('samples', query=form.searchquery.data))
                else:
                    flash("Sample not found")
                    return redirect('/results')
    	elif len(form.searchquery.data) == 64:
    		if collection.find({'results.sha256':form.searchquery.data},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False, 'results.scans': False}).count() != 0:
                    return redirect(url_for('samples', query=form.searchquery.data))
                else:
                    flash("Sample not found")
                    return redirect('/results')
    	else:
    		item = list(collection.find({'$text':{'$search':form.searchquery.data}},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False, 'results.scans': False}).limit(20))
                if not item:
                    flash("No samples found")
                    return redirect('/results')
                else:
                    while item:
                        result = item.pop()
                        flash(result)
                        if not item:
                            return redirect('/results')
    return render_template('search.html', 
                           title='Search',
                           form=form)

@app.route('/last10')
def last():
    collection = mongoconnect()
    item = list(collection.find({},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False, 'results.scans': False}).sort([('_id', -1)]).limit(10))
    if not item:
        flash("Something Went Wrong Here. Oops.")
        return redirect('/results')
    else:
        while item:
            result = item.pop()
            flash(result)
            if not item:
                 return render_template('last10.html', title='Last 10 Added Samples')
#                return redirect('/results')

@app.route('/results')
def results():
	return render_template('results.html', title='Results')

@app.route('/samples/<query>')
def samples(query):
    collection = mongoconnect()
    if len(query) == 32:
        sample = list(collection.find({'results.md5':query},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False}))
        detects = list(collection.find({'results.md5':query},{'_id': False, 'results.scans': True}))
        results={}
        for product in detects[0]['results']['scans']:
            if detects[0]['results']['scans'][product]['result'] != None:
                results[product] = detects[0]['results']['scans'][product]['result']
        return render_template("samples.html", data=sample, query=query, title='Sample Info', detects=results)
    elif len(query) == 40:
        sample = list(collection.find({'results.sha1':query},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False}))
        detects = list(collection.find({'results.sha1':query},{'_id': False, 'results.scans': True}))
        results={}
        for product in detects[0]['results']['scans']:
            if detects[0]['results']['scans'][product]['result'] != None:
                results[product] = detects[0]['results']['scans'][product]['result']
        return render_template("samples.html", data=sample, query=query, title='Sample Info', detects=results)
    elif len(query) == 64:
        sample = list(collection.find({'results.sha256':query},{'_id': False, 'response_code': False, 'results.response_code': False, 'results.verbose_msg': False}))
        detects = list(collection.find({'results.sha256':query},{'_id': False, 'results.scans': True}))
        results={}
        for product in detects[0]['results']['scans']:
            if detects[0]['results']['scans'][product]['result'] != None:
                results[product] = detects[0]['results']['scans'][product]['result']
        return render_template("samples.html", data=sample, query=query, title='Sample Info', detects=results)

@app.route('/mu-1dc98c01-236d99ce-1020d606-9b85bb07')
def blitzio():
    return '42'

@app.route('/download/<query>')
def download(query):
    filename = query
    if len(query) == 32:
        s3_file_key = str(query[:1]+"/"+query[:2]+"/"+query[:3]+"/"+query[:4]+"/"+query[:5]+"/"+query)
        conn = boto.connect_s3(
            aws_access_key_id = S3_ACCESS_KEY,
            aws_secret_access_key = S3_SECRET_KEY,
            calling_format = boto.s3.connection.OrdinaryCallingFormat(),
        )
        bucket = conn.get_bucket(S3_BUCKET)
        key = bucket.get_key(s3_file_key)
        if key == None:
            flash('File does not exist')
            return redirect('/results')
        else:
            key.get_contents_to_filename('/tmp/'+filename)
            pyminizip.compress('/tmp/'+filename, '/tmp/'+filename+'.zip', 'malware', 0)
            with open('/tmp/'+filename+'.zip', 'r') as f:
                body = f.read()
            unlink('/tmp/'+filename)
            unlink('/tmp/'+filename+'.zip')
            response = make_response(body)
            response.headers["Content-Disposition"] = "attachment; filename=%s" % filename+'.zip'
            return response
    else:
        flash('Provide valid MD5')
        return redirect('/results')

@app.route('/robots.txt')
def robots():
	response = make_response('User-agent: *\nDisallow: /download/')
	response.headers["content-type"] = "text/plain"
	return response

@app.route('/hashes')
def hashes():
	conn = boto.connect_s3(
            aws_access_key_id = S3_ACCESS_KEY,
            aws_secret_access_key = S3_SECRET_KEY,
            calling_format = boto.s3.connection.OrdinaryCallingFormat(),
        )
	bucket = conn.get_bucket(S3_MD5_BUCKET)
	list = [(keys.last_modified, keys) for keys in bucket]
	key = sorted(list, cmp=lambda x,y: cmp(x[0], y[0]))[-1][1]
	date = sorted(list, cmp=lambda x,y: cmp(x[0], y[0]))[-1][0]
	date = datetime.datetime.strptime(date, '%Y-%m-%dT%H:%M:%S.%fZ').replace(microsecond=0)
	url = key.generate_url(expires_in=0, query_auth=False)
	return render_template("hashes.html", date=date, url=url, title="MD5 hashes")
